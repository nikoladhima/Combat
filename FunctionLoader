local aim ={}

function aim:getclosestplayer()
      local maxdist = math.huge
      targetplayer = nil
      
      for _, plr in pairs(players:GetPlayers()) do
      if plr ~= player then
      local hasTeams = #game:GetService("Teams"):GetTeams() > 0
      if not teamCheck or not hasTeams or plr.Team ~= player.Team then
      checkdowned(plr)
      if not isdowned then
      local char = plr.Character
      if char then
      local part
      
      if char:FindFirstChild(selectedpart) then
      part = char[selectedpart]
      else
      local partmap = {
      ["Head"] = "Head",
      ["UpperTorso"] = "Torso",
      ["LowerTorso"] = "Torso",
      ["HumanoidRootPart"] = "HumanoidRootPart",
      ["LeftUpperArm"] = "Left Arm",
      ["RightUpperArm"] = "Right Arm",
      ["LeftUpperLeg"] = "Left Leg",
      ["RightUpperLeg"] = "Right Leg"
      }
      
      part = char:FindFirstChild(partmap[selectedpart] or "Torso")
      end
      
      if part then
      local screenpoint = camera:WorldToScreenPoint(part.Position)
      local dist = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(screenpoint.X, screenpoint.Y)).Magnitude
      if dist < maxdist then
      if not wallCheck or (wallCheck and isplayervisible(part.Position)) then
      maxdist = dist
      targetplayer = plr
      end
      end
      end
      end
      end
      end
      end
      end
      end

      function aim:getpredictedposition(part)
        local position = part.Position
        if usemanualprediction then
        predictedpos = position + (part.Velocity * prediction)
        else
        local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
        local velocity = part.AssemblyLinearVelocity
        predictedpos = position + (velocity * ping)
        end
        end

      function aim:lockonto()
       if targetplayer then
           checkdowned(targetplayer)
           if not isdowned then
               local character = targetplayer.Character
               if character then
                   local part = character:FindFirstChild(selectedpart)
                   if part then
                       getpredictedposition(part)
                       local offset = Vector3.new(0, 0, 0)
   
                       -- Check if the targeting is from an exploiter (anti-lock for exploiters)
                           -- Apply an anti-lock resolver for exploiters
                           -- Apply subtle deviations to the predicted aim point
                           if antilockresolver then
                           local resolverOffset = Vector3.new(math.random() * 0.2, math.random() * 0.2, math.random() * 0.2)  -- Random offset for anti-lock resolution
                           predictedpos = predictedpos + resolverOffset
                           end
   
                       -- Create the target CFrame for aiming
                       local targetCFrame = CFrame.lookAt(camera.CFrame.Position, predictedpos + offset)
                       
                       -- Smooth aiming behavior for legitimate aimbots
                       if smoothAimEnabled then
                           camera.CFrame = camera.CFrame:Lerp(targetCFrame, 1/smoothness)
                       else
                           camera.CFrame = targetCFrame
                       end
                   end
               end
           else
               aimbotenabled = false
           end
       end
   end

return aim
